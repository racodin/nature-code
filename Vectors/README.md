# 제1장. Vectors

이책은 우리 주변의 세상을 보고 코드로 세상을 시뮬레이션 할 수 있는 영리한 방법을 제시합니다. 이책은 세가지 부분으로 나뉘어 기본 물리를 살펴 보는 것으로 시작합니다. 어떻게 사과가 나무에서 떨어지는지 시계의 추가 흔들리거나 지구가 태양을 중심으로 회전하는 등입니다. 이책의 처음 5장에 포함된 모든 것은 절대적으로 모션 프로그래밍을 위한 가장 기본적인 구성 요소인 **벡터**를 사용해야합니다. 그리고 이것이 우리가 이야기를 시작하려는 것입니다.

이제 벡터의 단어는 많은 다른 것들을 의미 할 수 있습니다. 벡터는 1980년대 초 캘리포니아 새크라멘토에서 형성된 뉴 웨이브 록밴드의 이름이며 Kellogg 's Canada에서 제조한 아침 식사 시리얼의 이름이기도 합니다. 역학 분야에서는 벡터가 한 호스트에서 다른 호스트로 감염을 전염시키는 유기체를 설명하는데 사용됩니다. C++ 프로그래밍 언어에서 벡터(std :: vector)는 동적으로 크기를 조정할 수있는 배열 데이터 구조를 구현한 것입니다. 이 모든 정의는 흥미롭지만 우리가 원하는 것이 아닙니다. 우리가 원하는 것은 **유클리드 벡터**(그리스 수학자 유클리드로 명명되었으며 기하 벡터라고도 함)입니다. 이 책에서 "벡터"라는 용어를 볼 때, 크기와 방향이 모두 있는 엔티티로 정의된 유클리드 벡터를 의미한다고 가정 할 수 있습니다.

벡터는 일반적으로 화살표로 그려지며 방향은 화살표가 가리키는 위치와 화살표 자체의 길이로 표시됩니다.

![그림 1.1](https://natureofcode.com/book/imgs/chapter01/ch01_01.png)
*그림 1.1 : 화살표로 그려진 벡터에는 크기(화살표 길이)와 방향(화살표 방향)이 있습니다.*

위 그림에서 벡터는 포인트 A에서 포인트 B의 화살표로 표시되며 A에서 B로 이동하는 방법에 대한 지침으로 사용됩니다.

## 1.1 Vectors, You Complete Me

벡터에 대한 자세한 내용을 살펴보기 전에 먼저 벡터에 관심을 가져야하는 기본적인 예제를 살펴 보겠습니다. 입문 Processing 교과서를 읽거나 Processing 프로그래밍에 대한 수업을 한 번이라도 받은 경우가 있다면 간단하게 튀기는 공의 스케치 작성 방법을 배웠을 것입니다.

> 예제 1.1 : 벡터 없이 튀기는 공

```java
float x = 100;
float y = 100;
float xspeed = 1;
float yspeed = 3.3;

void setup() {
  size(640,360);
  background(255);
}

void draw() {
  background(255);

  x = x + xspeed;
  y = y + yspeed;

  if ((x > width) || (x < 0)) {
    xspeed = xspeed * -1;
  }
  if ((y > height) || (y < 0)) {
    yspeed = yspeed * -1;
  }

  stroke(0);
  fill(175);
  ellipse(x,y,16,16);
}
```

위의 예제에서 우리는 매우 단순한 세계, 즉 원형 모양(“공”)이 있는 빈 캔버스를 돌아 다닙니다. 이 공에는 코드에 변수로 표시되는 몇 가지 속성이 있습니다.

```text
Location      x and y
Speed         xspeed and yspeed
```

고급 스케치에서는 더 많은 변수가 있다고 상상할 수 있습니다.

```text
Acceleration        xacceleration and yacceleration
Target location     xtarget and ytarget
Wind                xwind and ywind
Friction            xfriction and yfriction
```

이 세상의 모든 개념(바람, 위치, 가속 등)에 대해 두 가지 변수가 필요하다는 것이 명확해 졌습니다. 그리고 이것은 2차원 세계일뿐 3D세계에서는 *x, y, z, xspeed, yspeed, zspeed* 등이 필요합니다.

코드를 단순화하고 더 적은 변수를 사용할 수 있다면 좋지 않을까요?

대신에:

```java
float x;
float y;
float xspeed;
float yspeed;
```

우리는 단순히...

```java
Vector location;
Vector speed;
```

벡터 사용의 첫 단계를 수행해도 새로운 작업을 수행 할 수 없습니다. 벡터를 추가한다고 해서 마술처럼 Processing 스케치가 물리를 시뮬레이션 하지는 않습니다. 그러나 코드를 단순화하고 모션을 프로그래밍하는 동안 계속해서 반복되는 일반적인 수학 연산을 위한 일련의 기능을 제공합니다.

벡터에 대한 소개로서, 우리는 아주 오랜 시간 동안(적어도 처음 몇 장을 통과 할 때까지) 2차원으로 살 것입니다. 이러한 모든 예제는 3차원으로 상당히 쉽게 확장 될 수 있으며 3차원에서 사용할 수 있는 클래스 인 *PVector*를 쉽게 확장 할 수 있습니다. 그러나 2개로 시작하는 것이 더 쉽습니다.

## 1.2 Vectors for Processing Programmers

벡터를 생각하는 한 가지 방법은 두 점의 차이입니다. 한 지점에서 다른 지점으로 이동하라는 지침을 제공하는 방법을 고려하십시오.

다음은 몇 가지 벡터와 가능한 번역입니다.

![그림 1.2](https://natureofcode.com/book/imgs/chapter01/ch01_02.png)
*그림 1.2*

```text
(-15, 3)      서쪽으로 15걸음 북쪽으로 3걸음 걸어가세오.
(3, 4)        동쪽으로 3걸음 북쪽으로 5걸음 걸어가세오.
(2, -1)       동쪽으로 2걸음 남쪽으로 1걸음 걸어가세오.
```

모션을 프로그래밍 할 때 이 작업을 수행했을 것입니다. 애니메이션의 모든 프레임(즉, Processing의 *draw()* 루프를 통한 단일주기)마다 화면의 각 객체가 특정 수의 픽셀을 수평, 수직으로 이동하도록 지시합니다.

![그림 1.3](https://natureofcode.com/book/imgs/chapter01/ch01_03.png)
*그림 1.3*

모든 프레임에 대해: **new location = velocity applied to current location**

속도가 벡터(두 점의 차이)인 경우 위치는 무엇입니까? 그것도 벡터일까요? 기술적으로, 한 지점에서 다른 지점으로 이동하는 방법을 설명하지 않기 때문에 위치가 벡터가 아니라고 주장 할 수 있습니다. 단순히 공간의 단일 지점을 설명하는 것입니다.

그럼에도 불구하고 위치를 설명하는 또 다른 방법은 출발지에서 해당 위치에 도달하기 위한 경로입니다. 따라서 위치는 위치와 원점의 차이를 나타내는 벡터 일 수 있습니다.

![그림 1.4](https://natureofcode.com/book/imgs/chapter01/ch01_04.png)
*그림 1.4*

위치와 속도에 대한 기본 데이터를 살펴 보겠습니다. 튀기는 공 예제에서 다음을 같았습니다.

```text
location      x,y
velocity      xspeed,yspeed
```

두 개의 부동 소수점 숫자 *x*와 *y*에 대해 동일한 데이터를 저장하는 방법에 주목하십시오. 벡터 클래스를 직접 작성하려면 다소 기본적인 것으로 시작해야합니다.

```java
class PVector {

  float x;
  float y;

  PVector(float x_, float y_) {
    x = x_;
    y = y_;
  }

}
```

핵심적으로 *PVector*는 두가지 값(또는 3D 예제에서 볼 수 있듯이 3 개)을 저장하는 편리한 방법입니다.

그리고 이것은...

```java
float x = 100;
float y = 100;
float xspeed = 1;
float yspeed = 3.3;
```

이렇게...

```java
PVector location = new PVector(100,100);
PVector velocity = new PVector(1,3.3);
```

이제 두 개의 벡터 객체(위치 및 속도)가 준비 되었으므로 **location = location + velocity**라는 모션 알고리즘을 구현할 준비가 되었습니다. 벡터가 없는 예제 1.1에서는 다음과 같은 결과를 얻었습니다.

```text
x = x + xspeed;
y = y + yspeed;
```

이상적인 세계에서는 위와 같은 코드는 다음과 같이 재작성할 수 있습니다.

```text
location = location + velocity;
```

그러나 처리에서 덧셈 연산자 +는 기본값(정수, 부동 수 등)에 대해서만 예약되어 있습니다. Processing은 두 개의 *PFont* 객체 또는 *PImage* 객체를 추가하는 방법을 아는 것보다 두 개의 *PVector* 객체를 함께 추가하는 방법을 모릅니다. 다행스럽게도 PVector 클래스에는 일반적인 수학 연산을 위한 함수가 포함되어 있습니다.

## 1.3 Vector Addition

*PVector* 클래스와 *add()* 메소드(Processing 자체에서 이미 구현 되었으므로 학습을 위해 순수하게)를 살펴보기 전에 수학 및 물리 교과서에 있는 표기법을 사용하여 벡터 추가를 살펴 보겠습니다.

벡터는 일반적으로 굵은 체로 표시되거나 위쪽에 화살표가 표시됩니다. 이 책의 목적상, **벡터**를 **스칼라**와 구별하기 위해(스칼라는 정수 또는 부동 소수점 숫자와 같은 단일 값을 나타냄) 화살표 표기법을 사용합니다.

* Vector: →u
* Scalar: x

다음 두 벡터가 있다고 가정 해 보겠습니다.

![그림 1.5](https://natureofcode.com/book/imgs/chapter01/ch01_05.png)
*그림 1.5*

각 벡터에는 x와 y의 두가지 구성 요소가 있습니다. 두 벡터를 더하려면 x와 y를 모두 추가하면 됩니다.

![그림 1.6](https://natureofcode.com/book/imgs/chapter01/ch01_06.png)

다시 말해:

→w = →u + →v

다음과 같이:

w.x = u.x + v.x
w.y = u.y + v.y

그런 다음 u와 v를 그림 1.6의 값으로 바꾸면 다음과 같은 결과를 얻습니다.

w.x = 5 + 3

w.y = 2 + 4

어떤 의미냐면:

w.x = 8 w.y = 6

마지막으로 이를 벡터로 작성합니다.

→w = (8, 6)
